\newpage 
\chapter{Тема 25 Основы технологии COM, COM++. Распределенное программирование.}

\begin{center}{\bfseries Технологии компонентного программирования. История и принципы функционирования COM, COM++, .NET и будущее COM. Основы распределенного программирования.}
\end{center}
  
Прежде всего, сформулируем основополагающее для рассматриваемого подхода определение компонента. Под компонентом будем далее иметь в виду независимый модуль программного кода, предназначенный для повторного использования и развертывания. Как видно из определения, применение компонентного программирования призвано обеспечить более простую, быструю и прямолинейную процедуру первоначальной инсталляции прикладного программного обеспечения, а также увеличить процент повторного использования кода, т.е. усилить основные преимущества ООП.

Говоря о свойствах компонентов, следует прежде всего отметить, что это существенно более крупные единицы, чем объекты (в том смысле, что объект представляет собой конструкцию уровня языка программирования). Другими отличиями компонентов от традиционных объектов являются возможность содержать множественные классы и (в большинстве случаев) независимость от языка программирования.

\begin{opr} 
  СОМ (Component Object Model - Модель многокомпонентных объектов) - является объектно-ориентированной концепцией, описывающей правила построения классов, называемых СОМ-объектами, с целью обеспечения взаимодействия между ними вне зависимости от языка, на котором реализованы данные классы, и среды, в которой выполняются приложения, содержащие их.
\end{opr}

Объекты СОМ реализуются в специальном двоичном формате, являющимся фактически описанием класса, и не зависящем от языка разработки, и предоставляют свою функциональность (позволяют вызывать свои методы) через набор интерфейсов.

\begin{utv}
  Каждый СОМ-объект реализует как минимум один интерфейс  IUnknown, выполняющий следующие действия: 
  \begin{enumerate}
    \item Поддержка счетчика экземпляров объекта с помощью методов AddRef, вызываемого при создании экземпляра класса для увеличения значения счетчика, и Release, вызываемого при разрушении экземпляра для уменьшения значения счетчика;
    \item Предоставление ссылки на интерфейс, заданный его уникальным идентификатором, и поддерживаемый СОМ-объектом, с помощью метода Query Interface.
  \end{enumerate}
\end{utv}

Для идентификации СОМ-объектов применяются глобальные уникальные идентификаторы, представляющие собой 128-разрядные целые числа, записываемые в следующем формате, где вместо символа 'х' указывается шестнадцатеричная цифра: 

(хххххххх-хххх-хххх-хххх-хххххххххххх)

\begin{example}
  Например, главное приложение графического редактора Adobe Photoshop имеет такой идентификатор: (43191D98-5D34-4103-BE42-226A55C2312A).
\end{example}

\begin{utv}
  Технология СОМ имеет два явных плюса:
  \begin{enumerate}
    \item создание СОМ-объектов не зависит от языка программирования. Таким образом, СОМ-объекты могут быть написаны на различных языках;
    \item СОМ-объекты могут быть использованы в любой среде программирования под Windows. В число этих сред входят Delphi, Visual C++, C++Builder, Visual Basic, и многие другие.
  \end{enumerate}
\end{utv}

\begin{note}
  Хотя технология СОМ обладает явными плюсами, она имеет также и минусы, среди которых зависимость от платформы. То есть, данная технология применима только в операционной системе Windows и на платформе Intel.
\end{note}

До появления COM существовало множество разрозненных сервисов, выполняемых в среде MS Windows. Каждый из них выполнял или выполняет лишь свои узкие (или не очень) задачи. Чаще всего эти сервисы были совершенно несовместимы друг с другом и требовали от программиста сразу нескольких технологий. Например, при статической компоновке с исполняемым модулем, запуске приложением другого приложения или вызовом программным модулем функций ОС – везде используются разные механизмы доступа составных частей ПО друг к другу. Таким образом, из разрозненных частей, таких, как Windows API, DDE, VBX и др., практически невозможно построить единую, устойчивую работающую систему обеспечивающую реальный рефакторинг (повторное использование исходного кода).

COM представляет собой универсальный способ взаимодействия программных модулей. В этой спецификации, разработанной компанией Microsoft, описаны требования, следуя которым становится возможным создание компонентов, предоставляющие свои сервисы единообразно. Причем вне зависимости от ЯП или используемой IDE. 

Модель COM определяет бинарный стандарт для построения компонентов приложений, а также принципов их взаимодействия друг с другом. Физическим воплощением является скомпилированный (в любой среде программирования) двоичный модуль, полностью соответствующий требуемым стандартам. Способ взаимодействия, который определяет COM, дает программисту прочный фундамент для создания легко расширяемого, модульного, переносимого ПО.

Все СОМ-объекты обычно содержатся в файлах с расширением DLL или OCX. Один такой файл может содержать как одиночный СОМ-объект, так и несколько СОМ-объектов. Ключевым аспектом технологии СОМ является возможность предоставления связи и взаимодействия между компонентами и приложениями, а также реализация клиент-сервер при помощи интерфейсов.

Microsoft Transaction Server был включен в Option Pack для Windows NT4 еще в 1997 году. В составе Windows 2000 была выпущена технология СOM+, которая являлась новой версией Microsoft Transaction Server. Технология расширяла возможности разработчиков COM-компонентов, предоставляя им некоторые готовые услуги, например:

\begin{enumerate}
  \item Автоматический пул потоков, создаваемый стандартным процессом-загрузчиком mtx.exe
  \item Доступ к контексту, в котором выполняется компонент (например, компоненты, используемые в ASP, могут с этой возможностью получить доступ к внутренним объектам той страницы, на которой они выполняются).
  \item Интеграция с транзакциями монитора MS DTC (контекст COM+ может автоматически содержать в себе транзакцию MS DTC)
\end{enumerate}

MTS/COM+ использовался внутри ряда версий веб-сервера MS IIS для загрузки и исполнения веб-приложений, как бинарных по технологии ISAPI, так и скриптовых по технологии ASP (сама ASP.dll есть ISAPI-приложение). COM+ объединяет компоненты в так называемые приложения COM+, что упрощает администрирование и обслуживание компонентов. Безопасность и производительность – основные направления усовершенствований СОМ+. Некоторые идеи, заложенные в основу COM+, были также реализованы в Microsoft.NET.

Технология СОМ реализуется с помощью СОМ-библиотек (в число которых входят такие файлы операционной системы, как OLE32.DLL и OLE-Aut32.DLL). СОМ-библиотеки содержат набор стандартных интерфейсов, которые обеспечивают функциональность СОМ-объекта, а также небольшой набор функций API, отвечающих за создание и управление СОМ-объектов.

Набор правил определения интерфейсов компонентов и их реализаций, а также правил, по которым компоненты работают в системе и взаимодействуют друг с другом, принято объединять под именем компонентной модели (component model). В компонентную модель входят правила, регламентирующие жизненный цикл компонента, т.е. то, через какие состояния он проходит при своем существовании в рамках некоторой системы (незагружен, загружен и пассивен, активен, находится в кэше и пр.) и как выполняются переходы между этими состояниями. 

Существуют несколько компонентных моделей. Правильно взаимодействовать друг с другом могут только компоненты, построенные в рамках одной модели, поскольку компонентная модель определяет «язык», на котором компоненты могут общаться друг с другом. Помимо компонентной модели, для работы компонентов необходим некоторый набор базовых служб (basic services). Например, компоненты должны уметь находить друг друга в среде, которая, возможно, распределена на несколько машин. Компоненты должны уметь передавать друг другу данные, опять же, может быть, при помощи сетевых взаимодействий, но реализации отдельных компонентов сами по себе не должны зависеть от вида используемой связи и от расположения их партнеров по взаимодействию. Набор таких базовых, необходимых для функционирования большинства компонентов служб, вместе с поддерживаемой с их помощью компонентной моделью называется компонентной средой (или компонентным каркасом, component framework). Примеры известных компонентных сред — различные реализации J2EE, .NET, CORBA. Сами по себе J2EE, .NET и CORBA являются спецификациями компонентных моделей и набора базовых служб, которые должны поддерживаться их реализациями.

Построение распределенных систем высокого качества является одной из наиболее сложных задач разработки ПО. Технологии типа J2EE и .NET создаются как раз для того, чтобы сделать разработку широко встречающихся видов распределенных систем — так называемых бизнесприложений, поддерживающих решение бизнес-задач некоторой организации, — достаточно простой и доступной практически любому программисту. Основная задача, которую пытаются решить с помощью распределенных систем — обеспечение максимально простого доступа к возможно большему количеству ресурсов как можно большему числу пользователей. Наиболее важными свойствами такой системы являются прозрачность, открытость, масштабируемость и безопасность. 

\begin{opr}
  Прозрачность (transparency). Прозрачностью называется способность системы скрыть от пользователя физическое распределение ресурсов, а также аспекты их перераспределения и перемещения между различными машинами в ходе работы, репликацию.
\end{opr}

\begin{opr}
  Открытость (openness). Открытость системы определяется как полнота и ясность описания интерфейсов работы с ней и служб, которые она предоставляет через эти интерфейсы. 
\end{opr}

\begin{opr}
  Масштабируемость (scalability). Масштабируемость системы — это зависимость изменения ее характеристик от количества ее пользователей и подключенных ресурсов, а также от степени географической распределенности системы. 
\end{opr}

\begin{opr}
  Безопасность (safety). Так как распределенные системы вовлекают в свою работу множество пользователей, машин и географически разделенных элементов, вопросы их безопасности получают гораздо большее значение, чем при работе обычных приложений, сосредоточенных на одной физической машине. Это связано как с невозможностью надежно контролировать доступ к различным элементам такой системы, так и с ее доступностью для гораздо более широкого и разнообразного по своему поведению сообщества пользователей.
\end{opr}

В 2002 году была официально выпущена платформа Microsoft.NET, которая на сегодняшний день объявлена Microsoft рекомендуемой основой для создания приложений и компонентов под Windows. По этой причине в .NET включены и средства, позволяющие обращаться к компонентам COM из приложений .NET, и наоборот. Наиболее существенным нововведением идеологии Microsoft .NET является компонентно-ориентированный подход к программированию. Cледует отметить то обстоятельство, что компонентно-ориентированный подход к проектированию и реализации программных систем и комплексов является в некотором смысле развитием объектно-ориентированного и практически более пригоден для разработки крупных и распределенных систем (например, корпоративных приложений). По словам представителей Microsoft, СOM+ и .NET являются отлично взаимодополняющими технологиями.

\newpage 
\chapter{Тема 26 Библиотеки.}

\begin{center}{\bfseries Виды и необходимость использования библиотек.}
\end{center}

Более двух десятилетий растет и стремительно прогрессирует зависимость больших программных системы от программных библиотек. Практически все ПО требует использования больших и сложных программных библиотек, вдобавок к специальным прикладным библиотекам. Широкое использование множества библиотек потребовало новых механизмов для управления именами. Например, если разработчик добавляет новые имена в существующую библиотеку или создает новую библиотеку, он не должен задействовать такое имя, которое конфликтует с именем, уже определенным в клиентской прикладной программе или в некоторой другой библиотеке. 

Пространства имен фиксируют такие наборы имен, которые не станут источниками конфликтов. Каждая библиотека может создать свое собственное пространство имен, предотвращающее конфликты именования с другими библиотеками или с клиентскими программами. Каждая логическая часть программной системы может создать пространство имен с теми же целями.

\begin{opr}
  Типы модулей и элементов применяются в зависимости от поставленных задач. Различают следующие виды, открывающие возможность работы с любым видом софта:
  \begin{enumerate}
    \item использование математических операций;
    \item графические модули;
    \item компоненты для работы с файлами;
    \item модули для подключения и использования сети;
    \item элементы шифрования и защиты данных.
  \end{enumerate}
\end{opr}

Несмотря на обширное количество различных компонентов, в зависимости от известности языка, разработчики постоянно выпускают новые модули с кодом. Чем их больше, тем язык считается наиболее развитым. Условно можно разделить на открытые и коммерческие проекты:

\begin{enumerate}
  \item Открытые — находятся в свободном доступе. Любой разработчик может предложить исправленную версию кода.
  \item Коммерческие — создаются в студиях для продажи. Основными создателями являются штатный программист и тестировщик.
\end{enumerate}

Штатные сотрудники могут написать собственные модули под проект. Далее их можно использовать, как шаблон к стороннему софту. Также компоненты делятся по способу подключения к языку.
\begin{utv}
  Различают 2 типа:
  \begin{enumerate}
    \item Динамические библиотеки распространяются в виде объектных файлов – то есть с уже скомпилированным двоичным программным кодом. Для разных языков существуют разные расширения файлов, но особенно «примелькались» dll расширения – DLL Windows, стандартные расширения для Windows. Они поставляются сразу с операционной системой и позволяют быстро решать задачи, связанные с OC. «Фишка» динамических библиотек состоит как раз в том, что они прекомпилированы – их не нужно компилировать при подключении и обращении к ним, достаточно просто указать путь к библиотеке и вызвать нужный метод. Динамические библиотеки работают быстрее, но не позволяют заглянуть в исходники – вы увидите нечитаемый двоичный код.
    \item Статические — представлены в виде исходного кода, расположенного внутри программы. В отличие от динамических, провести изменения довольно сложно. Для этого придётся перейти в древо софта, провести изменения, заново запустить исходный код.
  \end{enumerate}
\end{utv}


Выбор типа подключения зависит от целей разработчика. Если необходимо часто менять данные и вносить правки, рекомендуется использовать динамическую модель. Статические более надёжные, так требуется время для изменения алгоритма.

Современный софт написан большим количеством кода. Использование стандартных элементов с нуля увеличивает время создания программы. Также если разработчик не использует отдельные компоненты, код программы становится объёмным и массивным. К преимуществам использования относят:

\begin{enumerate}
  \item экономия времени;
  \item структурирование информации;
  \item облегчение разработки;
  \item уменьшение количества ошибок в коде.
\end{enumerate}

Использование библиотек облегчает работу с кодом при разработке собственного софта. Разработчику не нужно думать о том, как написать кнопку или другие часто встречающиеся элементы. Достаточно прописать и подключить модуль, который откроет целый массив с нужными данными.

\begin{center}{\bfseries Как добавляются библиотеки.}
\end{center}

Зависит от языка, но обычно исполняемый код подключается через инструкцию include, после которой следует адрес библиотеки, которую нужно подключить. 

\begin{utv}
  В зависимости от способа подключения различают два типа библиотек:
  \begin{enumerate}
    \item Динамические. Принцип работы предусматривает подключение машинного кода непосредственно в процессе исполнения программы. Если необходимо, его можно заменить, что становится как плюсом, так и минусом динамических библиотек. Дело в том, что замена с равным успехом происходит как на что-то хорошее и полезное, так и на вредоносный вирус.
    \item Статические. В этом случае речь идет об объектном модуле или исходном коде, написанном на языке программы, которую использует разработчик. Замена библиотеки в подобной ситуации представляет собой нетривиальную задачу, решение которой требует серьезных усилий и временных затрат.
  \end{enumerate}
\end{utv}